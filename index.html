<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>JEE Ascent: Zenith Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Basic Styling --- */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #0c0a17; /* Dark background */
            font-family: 'Poppins', sans-serif;
        }
        /* --- Canvas Styling --- */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <canvas id="appCanvas"></canvas>

    <script>
    // --- Application Entry Point ---
    window.onload = () => {
        const canvas = document.getElementById('appCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- Core Application Class ---
        class JEEAscentApp {
            constructor() {
                this.canvas = canvas;
                this.ctx = ctx;
                this.lastTime = 0;
                this.glowAnimation = 0; // For breathing glow effect
                this.currentTab = 'Dashboard';
                this.transition = { alpha: 1, state: 'in', targetTab: 'Dashboard' };
                this.particles = [];
                this.touch = { startX: 0, startY: 0, currentY: 0, isDragging: false, scrollOffset: 0, targetScroll: 0 };
                this.activeInput = null; // For handling text input
                this.keyboardVisible = false;

                // --- Syllabus Data ---
                this.syllabus = {
                    Physics: ["Units and Measurements", "Kinematics", "Laws of Motion", "Work, Energy and Power", "Rotational Motion", "Gravitation", "Properties of Solids and Liquids", "Thermodynamics", "Kinetic Theory of Gases", "Oscillations and Waves", "Electrostatics", "Current Electricity", "Magnetic Effects of Current", "Electromagnetic Induction and AC", "Electromagnetic Waves", "Optics", "Dual Nature of Matter and Radiation", "Atoms and Nuclei", "Electronic Devices", "Communication Systems"],
                    Chemistry: ["Basic Concepts of Chemistry", "Structure of Atom", "Classification of Elements", "Chemical Bonding", "States of Matter", "Thermodynamics", "Equilibrium", "Redox Reactions", "Hydrogen", "s-Block Elements", "p-Block Elements (Group 13 & 14)", "Organic Chemistry: Basic Principles", "Hydrocarbons", "Environmental Chemistry", "Solid State", "Solutions", "Electrochemistry", "Chemical Kinetics", "Surface Chemistry", "p-Block Elements (Group 15-18)", "d and f Block Elements", "Coordination Compounds", "Haloalkanes and Haloarenes", "Alcohols, Phenols and Ethers", "Aldehydes, Ketones and Carboxylic Acids", "Amines", "Biomolecules", "Polymers", "Chemistry in Everyday Life"],
                    Mathematics: ["Sets, Relations and Functions", "Complex Numbers", "Matrices and Determinants", "Permutations and Combinations", "Binomial Theorem", "Sequence and Series", "Limit, Continuity and Differentiability", "Integral Calculus", "Differential Equations", "Coordinate Geometry", "Three Dimensional Geometry", "Vector Algebra", "Statistics and Probability", "Trigonometry", "Mathematical Reasoning"]
                };

                // --- Motivational Content ---
                this.quotes = ["The will to win, the desire to succeed, the urge to reach your full potential... these are the keys that will unlock the door to personal excellence.", "Believe you can and you're halfway there.", "Success is not final, failure is not fatal: it is the courage to continue that counts.", "The secret of getting ahead is getting started.", "Don't watch the clock; do what it does. Keep going."];
                this.affirmations = ["I am focused and disciplined.", "Every challenge is an opportunity to grow stronger.", "I am capable of achieving my goals.", "I trust in my abilities and my preparation.", "I am calm, confident, and ready to succeed."];
                this.tips = ["Solve previous year papers religiously.", "Focus on understanding concepts over rote learning.", "Consistent revision is more important than learning new topics at the last minute.", "Take scheduled breaks to avoid burnout.", "Analyze your mock tests to identify weak areas."];

                // --- Application State ---
                this.state = this.loadState();
                
                this.resizeCanvas();
                this.initEventListeners();
                this.gameLoop(0);
            }

            // --- State Management ---
            defaultState() {
                const syllabusState = {};
                Object.keys(this.syllabus).forEach(subject => {
                    syllabusState[subject] = this.syllabus[subject].map(chapter => ({ name: chapter, status: 'Pending', completionDate: null }));
                });

                return {
                    onboardingComplete: false,
                    userName: '',
                    streak: 0,
                    lastCompletedDate: null,
                    weeklyGoals: [{ text: '', done: false }, { text: '', done: false }, { text: '', done: false }],
                    dailyMission: { text: '', done: false },
                    pomodoro: { mode: 'work', time: 25 * 60, isRunning: false, totalFocusTime: 0 },
                    syllabus: syllabusState,
                    revisions: [],
                    performance: [],
                    completedDays: {}
                };
            }

            loadState() {
                const savedState = localStorage.getItem('jeeAscentData');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    // Basic migration: ensure new features have default values
                    if (!parsedState.performance) parsedState.performance = [];
                    if (!parsedState.completedDays) parsedState.completedDays = {};
                    return parsedState;
                }
                return this.defaultState();
            }

            saveState() {
                localStorage.setItem('jeeAscentData', JSON.stringify(this.state));
            }
            
            checkStreak() {
                const today = new Date().toISOString().slice(0, 10);
                if (this.state.dailyMission.done) {
                    if (this.state.lastCompletedDate !== today) {
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        if (this.state.lastCompletedDate === yesterday.toISOString().slice(0, 10)) {
                            this.state.streak++;
                        } else {
                            this.state.streak = 1;
                        }
                        this.state.lastCompletedDate = today;
                        this.state.completedDays[today] = true;
                    }
                }
            }

            // --- Canvas & Event Handling ---
            resizeCanvas() {
                this.dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * this.dpr;
                this.canvas.height = window.innerHeight * this.dpr;
                this.ctx.scale(this.dpr, this.dpr);
                this.width = window.innerWidth;
                this.height = window.innerHeight;
            }

            initEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
                this.canvas.addEventListener('click', (e) => this.handleTap(e));
                
                // Touch events for scrolling
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));

                // Keyboard events for text input
                window.addEventListener('keydown', (e) => this.handleKeyPress(e));
            }
            
            getEventCoordinates(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX || e.touches[0].clientX) - rect.left;
                const y = (e.clientY || e.touches[0].clientY) - rect.top;
                return { x, y };
            }

            handleTap(e) {
                const { x, y } = this.getEventCoordinates(e);
                
                // Don't register taps while dragging
                if (this.touch.isDragging) return;

                if (this.state.onboardingComplete) {
                    this.checkUICollision(x, y, this.currentTab);
                    this.checkTabCollision(x, y);
                } else {
                    this.checkUICollision(x, y, 'Onboarding');
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const { x, y } = this.getEventCoordinates(e);
                this.touch.startX = x;
                this.touch.startY = y;
                this.touch.currentY = y;
                this.touch.isDragging = false;
                this.touch.targetScroll = this.touch.scrollOffset;
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const { y } = this.getEventCoordinates(e);
                const deltaY = y - this.touch.currentY;
                if (Math.abs(deltaY) > 5) this.touch.isDragging = true;
                
                this.touch.targetScroll += deltaY;

                // Clamp scrolling
                const scrollableHeight = this.getScrollableHeight(this.currentTab);
                const maxScroll = 0;
                const minScroll = Math.min(0, this.height - scrollableHeight - 150);
                this.touch.targetScroll = Math.max(minScroll, Math.min(maxScroll, this.touch.targetScroll));

                this.touch.currentY = y;
            }
            
            handleTouchEnd(e) {
                setTimeout(() => { this.touch.isDragging = false; }, 100);
            }
            
            handleKeyPress(e) {
                if (!this.activeInput) return;

                if (e.key === 'Enter') {
                    if (this.activeInput.multiline) {
                        this.activeInput.value += '\n';
                    } else {
                        if (this.activeInput.onEnter) this.activeInput.onEnter();
                        this.activeInput = null;
                        this.keyboardVisible = false;
                    }
                } else if (e.key === 'Backspace') {
                    this.activeInput.value = this.activeInput.value.slice(0, -1);
                } else if (e.key.length === 1) { // Regular character
                    this.activeInput.value += e.key;
                }
                 if(this.activeInput) this.state[this.activeInput.stateKey] = this.activeInput.value
            }


            // --- UI Collision & Interaction ---
            checkUICollision(x, y, screen) {
                // This is a simplified collision detection system. 
                // A more robust system would use a list of interactive elements.
                const w = this.width;
                const h = this.height;
                const centerX = w / 2;

                switch(screen) {
                    case 'Onboarding':
                        // Button to submit name
                        if (y > h * 0.55 && y < h * 0.55 + 50 && x > centerX - 75 && x < centerX + 75) {
                            if (this.state.userName.trim().length > 0) {
                                this.state.onboardingComplete = true;
                                this.saveState();
                            }
                        } else if (y > h * 0.45 && y < h * 0.45 + 50) { // Text input area
                            this.activeInput = {
                                value: this.state.userName,
                                stateKey: 'userName',
                                onEnter: () => {
                                    if(this.state.userName.trim().length > 0) {
                                        this.state.onboardingComplete = true;
                                        this.saveState();
                                    }
                                },
                                multiline: false
                            };
                            this.keyboardVisible = true;
                        }
                        break;
                    
                    case 'Dashboard':
                        // Pomodoro Timer
                        if (Math.sqrt((x-centerX)**2 + (y-h*0.45)**2) < 60){
                            this.state.pomodoro.isRunning = !this.state.pomodoro.isRunning;
                        }
                        // Daily Mission
                        if (x > w * 0.1 && x < w * 0.9 && y > h * 0.65 && y < h * 0.72) {
                             this.activeInput = {
                                value: this.state.dailyMission.text,
                                stateKey: 'dailyMission.text',
                                onEnter: () => {},
                                multiline: false
                            };
                        } else if (x > centerX - 75 && x < centerX + 75 && y > h*0.74 && y < h * 0.74 + 40 && this.state.dailyMission.text && !this.state.dailyMission.done) {
                            this.state.dailyMission.done = true;
                            this.spawnParticles(centerX, h*0.76);
                            this.checkStreak();
                        }
                        break;
                    
                     case 'Syllabus':
                        let yOffset = 80 + this.touch.scrollOffset;
                        Object.keys(this.state.syllabus).forEach(subject => {
                            yOffset += 50;
                            this.state.syllabus[subject].forEach(chapter => {
                                if (x > w * 0.1 && x < w * 0.9 && y > yOffset && y < yOffset + 45) {
                                    if (chapter.status === 'Pending') {
                                        chapter.status = 'Completed';
                                        chapter.completionDate = new Date().toISOString();
                                        this.scheduleRevisions(chapter.name, subject);
                                    } else {
                                        chapter.status = 'Pending';
                                        this.removeRevisions(chapter.name, subject);
                                        chapter.completionDate = null;
                                    }
                                }
                                yOffset += 55;
                            });
                            yOffset += 20;
                        });
                        break;
                    
                    case 'Revision':
                        let revYOffset = 80 + this.touch.scrollOffset;
                        this.getDueRevisions().forEach(rev => {
                             if (x > w * 0.1 && x < w * 0.9 && y > revYOffset && y < revYOffset + 50) {
                                // Find the original revision and mark it as done
                                const originalRev = this.state.revisions.find(r => r.id === rev.id);
                                if(originalRev) originalRev.done = true;
                                this.spawnParticles(centerX, revYOffset + 25);
                            }
                            revYOffset += 60;
                        });
                        break;
                }
            }

            checkTabCollision(x, y) {
                const tabWidth = this.width / 5;
                const tabY = this.height - 60;
                if (y > tabY) {
                    const tabIndex = Math.floor(x / tabWidth);
                    const tabs = ['Dashboard', 'Syllabus', 'Revision', 'Performance', 'Mindset'];
                    const newTab = tabs[tabIndex];
                    if (newTab && newTab !== this.currentTab) {
                        this.changeTab(newTab);
                    }
                }
            }
            
            changeTab(tabName) {
                if (this.transition.state !== 'in') return;
                this.transition.state = 'out';
                this.transition.targetTab = tabName;
                this.touch.scrollOffset = 0; // Reset scroll on tab change
                this.touch.targetScroll = 0;
            }

            // --- Revision Logic ---
            scheduleRevisions(chapterName, subject) {
                const now = new Date();
                const revisionDays = [1, 7, 30, 90];
                revisionDays.forEach(days => {
                    const revisionDate = new Date(now);
                    revisionDate.setDate(revisionDate.getDate() + days);
                    this.state.revisions.push({
                        id: `${subject}-${chapterName}-${days}`,
                        subject,
                        chapterName,
                        dueDate: revisionDate.toISOString(),
                        done: false
                    });
                });
            }
            
            removeRevisions(chapterName, subject) {
                this.state.revisions = this.state.revisions.filter(rev => rev.chapterName !== chapterName || rev.subject !== subject);
            }
            
            getDueRevisions() {
                const today = new Date();
                return this.state.revisions.filter(rev => {
                    const dueDate = new Date(rev.dueDate);
                    return !rev.done && dueDate <= today;
                }).sort((a,b) => new Date(a.dueDate) - new Date(b.dueDate));
            }

            // --- Particle System ---
            spawnParticles(x, y) {
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 100,
                        size: Math.random() * 3 + 1,
                        color: `hsla(${Math.random() * 360}, 100%, 70%, 1)`
                    });
                }
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; // gravity
                    p.life--;
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            // --- Drawing Utilities ---
            drawRoundedRect(x, y, w, h, r, color) {
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.moveTo(x + r, y);
                this.ctx.arcTo(x + w, y, x + w, y + h, r);
                this.ctx.arcTo(x + w, y + h, x, y + h, r);
                this.ctx.arcTo(x, y + h, x, y, r);
                this.ctx.arcTo(x, y, x + w, y, r);
                this.ctx.closePath();
                this.ctx.fill();
            }

            drawText(text, x, y, size, color, align = 'center', weight = 'normal', maxWidth) {
                this.ctx.font = `${weight} ${size}px Poppins`;
                this.ctx.fillStyle = color;
                this.ctx.textAlign = align;
                if (maxWidth) {
                    this.ctx.fillText(text, x, y, maxWidth);
                } else {
                    this.ctx.fillText(text, x, y);
                }
            }
            
            wrapText(text, x, y, maxWidth, lineHeight, color, size, weight = 'normal', align = 'center') {
                const words = text.split(' ');
                let line = '';
                this.ctx.font = `${weight} ${size}px Poppins`;
                this.ctx.fillStyle = color;
                this.ctx.textAlign = align;
                let testY = y;

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = this.ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        this.ctx.fillText(line, x, testY);
                        line = words[n] + ' ';
                        testY += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                this.ctx.fillText(line, x, testY);
            }

            // --- Getters ---
            getScrollableHeight(tab) {
                let h = this.height; // default
                switch (tab) {
                    case 'Syllabus':
                        h = 150; // Initial padding
                        Object.keys(this.state.syllabus).forEach(subject => {
                            h += 50; // Subject header
                            h += this.state.syllabus[subject].length * 55; // Chapters
                            h += 20; // Padding
                        });
                        break;
                    case 'Revision':
                         h = 100 + this.getDueRevisions().length * 60;
                         break;
                    case 'Performance':
                        // ... calculate based on tests ...
                        break;
                    case 'Mindset':
                        // ... calculate based on mindset widgets ...
                        break;
                }
                return h;
            }

            // --- Screen Drawing Methods ---
            drawOnboarding() {
                const w = this.width;
                const h = this.height;
                const centerX = w / 2;
                
                this.drawText("Welcome to JEE Ascent", centerX, h * 0.2, 28, '#FFF', 'center', '600');
                this.drawText("What should we call you?", centerX, h * 0.35, 18, '#aaa');

                // Draw text input box
                this.drawRoundedRect(w * 0.1, h * 0.45, w * 0.8, 50, 10, 'rgba(255, 255, 255, 0.1)');
                this.drawText(this.state.userName + (this.activeInput ? '_' : ''), centerX, h * 0.45 + 32, 20, '#FFF');
                
                // Draw button
                this.drawRoundedRect(centerX - 75, h * 0.55, 150, 50, 25, '#8a2be2');
                this.drawText("Let's Begin", centerX, h * 0.55 + 32, 18, '#FFF');
            }

            drawDashboard() {
                const w = this.width;
                const h = this.height;
                const centerX = w / 2;

                // Greeting
                this.drawText(`Let's conquer the day, ${this.state.userName}!`, centerX, 70, 22, '#FFF', 'center', '600');

                // Streak Counter
                const glow = 10 + Math.sin(this.glowAnimation) * 5;
                this.ctx.shadowBlur = glow;
                this.ctx.shadowColor = 'rgba(255, 215, 0, 0.7)';
                this.drawText(this.state.streak, centerX, h * 0.2, 70, '#FFD700', 'center', '700');
                this.drawText('Day Streak', centerX, h * 0.2 + 30, 18, '#FFD700');
                this.ctx.shadowBlur = 0; // Reset glow

                // Quote of the day
                const dayOfYear = Math.floor((new Date() - new Date(new Date().getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));
                const quote = this.quotes[dayOfYear % this.quotes.length];
                this.drawRoundedRect(w*0.1, h*0.28, w*0.8, 100, 15, 'rgba(255,255,255,0.05)');
                this.wrapText(`"${quote}"`, centerX, h*0.28 + 30, w*0.7, 22, '#DDD', 14, 'normal');

                // Pomodoro Timer
                const {mode, time, isRunning} = this.state.pomodoro;
                const minutes = Math.floor(time / 60);
                const seconds = time % 60;
                const progress = time / ((mode === 'work' ? 25 : 5) * 60);
                
                this.ctx.strokeStyle = '#8a2be2';
                this.ctx.lineWidth = 8;
                this.ctx.beginPath();
                this.ctx.arc(centerX, h*0.48, 60, -Math.PI/2, -Math.PI/2 + (1-progress) * 2 * Math.PI);
                this.ctx.stroke();

                this.drawText(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, centerX, h*0.48 + 10, 30, '#FFF', 'center', '600');
                this.drawText(isRunning ? 'PAUSE' : 'START', centerX, h*0.48 + 40, 14, '#AAA', 'center');

                // Daily Mission
                 this.drawRoundedRect(w * 0.1, h * 0.65, w * 0.8, 50, 10, 'rgba(255, 255, 255, 0.05)');
                 this.drawText("Today's Main Goal:", w*0.15, h * 0.65 - 10, 14, '#AAA', 'left');
                 this.drawText(this.state.dailyMission.text || 'Tap to set mission...', w*0.15, h * 0.65 + 32, 16, '#FFF', 'left');
                 if(this.state.dailyMission.text) {
                     this.drawRoundedRect(centerX-75, h*0.74, 150, 40, 20, this.state.dailyMission.done ? '#28a745' : '#8a2be2');
                     this.drawText(this.state.dailyMission.done ? 'Completed!' : 'Mark as Done', centerX, h*0.74+26, 16, '#FFF');
                 }
            }

            drawSyllabus() {
                 const w = this.width;
                 const h = this.height;
                 const centerX = w/2;
                 this.drawText('Syllabus Hub', centerX, 40, 24, '#FFF', 'center', '600');

                 this.ctx.save();
                 this.ctx.translate(0, this.touch.scrollOffset);

                 let yOffset = 80;
                 Object.keys(this.state.syllabus).forEach(subject => {
                    this.drawText(subject, centerX, yOffset + 20, 20, '#8a2be2', 'center', '600');
                    yOffset += 50;

                    this.state.syllabus[subject].forEach(chapter => {
                         this.drawRoundedRect(w * 0.1, yOffset, w * 0.8, 45, 10, chapter.status === 'Completed' ? 'rgba(40, 167, 69, 0.3)' : 'rgba(255, 255, 255, 0.05)');
                         this.drawText(chapter.name, w * 0.15, yOffset + 28, 14, '#FFF', 'left', '400', w * 0.6);
                         if (chapter.status === 'Completed') {
                              this.drawText('‚úî', w*0.85, yOffset + 28, 16, '#28a745', 'right');
                         }
                         yOffset += 55;
                    });
                     yOffset += 20;
                 });
                this.ctx.restore();
            }

            drawRevision() {
                const w = this.width;
                const h = this.height;
                const centerX = w / 2;
                this.drawText('Revision Hub', centerX, 40, 24, '#FFF', 'center', '600');

                const dueRevisions = this.getDueRevisions();
                
                if (dueRevisions.length === 0) {
                    this.drawText("You're all caught up!", centerX, h / 2, 20, '#AAA');
                    this.drawText("Great work!", centerX, h / 2 + 30, 16, '#AAA');
                    return;
                }
                
                this.ctx.save();
                this.ctx.translate(0, this.touch.scrollOffset);

                let yOffset = 80;
                dueRevisions.forEach(rev => {
                    this.drawRoundedRect(w * 0.1, yOffset, w * 0.8, 50, 10, 'rgba(255, 215, 0, 0.1)');
                    this.drawText(rev.chapterName, w * 0.15, yOffset + 22, 14, '#FFD700', 'left');
                    this.drawText(rev.subject, w * 0.15, yOffset + 40, 12, '#AAA', 'left');
                    
                    const dueDate = new Date(rev.dueDate);
                    const today = new Date();
                    const diffDays = Math.ceil((today - dueDate) / (1000 * 60 * 60 * 24));
                    const dueText = diffDays <= 0 ? "Due Today" : `${diffDays} days overdue`;
                    this.drawText(dueText, w * 0.85, yOffset + 32, 12, diffDays > 0 ? '#ff4d4d' : '#FFD700', 'right');

                    yOffset += 60;
                });
                
                this.ctx.restore();
            }

            drawPerformance() {
                 this.drawText('Performance Hub', this.width/2, 40, 24, '#FFF', 'center', '600');
                 this.drawText('Coming Soon!', this.width/2, this.height/2, 20, '#AAA', 'center', '400');
            }

            drawMindset() {
                const w = this.width;
                const h = this.height;
                const centerX = w/2;
                this.drawText('Mindset Hub', centerX, 40, 24, '#FFF', 'center', '600');

                // Daily Affirmation
                const dayOfYear = Math.floor((new Date() - new Date(new Date().getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));
                const affirmation = this.affirmations[dayOfYear % this.affirmations.length];
                this.drawRoundedRect(w*0.1, 80, w*0.8, 80, 15, 'rgba(138, 43, 226, 0.2)');
                this.wrapText(affirmation, centerX, 110, w * 0.7, 24, '#e0b0ff', 18, '500');

                // Progress Card
                this.drawRoundedRect(w*0.1, 180, w*0.8, 120, 15, 'rgba(255,255,255,0.05)');
                const totalChapters = Object.values(this.state.syllabus).flat().length;
                const completedChapters = Object.values(this.state.syllabus).flat().filter(c => c.status === 'Completed').length;
                const completionPercentage = totalChapters > 0 ? (completedChapters / totalChapters) : 0;
                
                // Pie Chart
                this.ctx.strokeStyle = '#555';
                this.ctx.lineWidth = 10;
                this.ctx.beginPath();
                this.ctx.arc(w*0.28, 240, 35, 0, 2 * Math.PI);
                this.ctx.stroke();

                this.ctx.strokeStyle = '#8a2be2';
                this.ctx.beginPath();
                this.ctx.arc(w*0.28, 240, 35, -Math.PI/2, -Math.PI/2 + completionPercentage * 2 * Math.PI);
                this.ctx.stroke();
                this.drawText(`${Math.round(completionPercentage*100)}%`, w*0.28, 245, 16, '#FFF', 'center', '600');
                
                // Stats Text
                this.drawText('Syllabus', w*0.28, 290, 12, '#AAA');
                this.drawText(completedChapters.toString(), w * 0.55, 230, 24, '#FFF', 'center', '600');
                this.drawText('Chapters Done', w*0.55, 250, 12, '#AAA');
                
                const focusHours = (this.state.pomodoro.totalFocusTime / 3600).toFixed(1);
                this.drawText(focusHours, w*0.8, 230, 24, '#FFF', 'center', '600');
                this.drawText('Focus Hours', w*0.8, 250, 12, '#AAA');

                // Streak Calendar
                this.drawText('Commitment Calendar', centerX, 330, 18, '#FFF', '600');
                this.drawCalendar(w * 0.1, 350, w*0.8);
            }
            
            drawCalendar(x, y, width) {
                const today = new Date();
                const month = today.getMonth();
                const year = today.getFullYear();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                
                const daySize = width / 7;
                const days = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
                
                // Draw day headers
                for (let i = 0; i < 7; i++) {
                    this.drawText(days[i], x + i * daySize + daySize / 2, y + 15, 12, '#888');
                }

                let currentDay = 1;
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 7; col++) {
                        if ((row === 0 && col < firstDayOfMonth) || currentDay > daysInMonth) {
                            continue;
                        }
                        const dayX = x + col * daySize + daySize / 2;
                        const dayY = y + 30 + row * daySize + daySize / 2;
                        
                        const dateString = `${year}-${(month + 1).toString().padStart(2,'0')}-${currentDay.toString().padStart(2,'0')}`;

                        // Highlight completed day
                        if (this.state.completedDays[dateString]) {
                            this.ctx.fillStyle = 'rgba(138, 43, 226, 0.5)';
                            this.ctx.beginPath();
                            this.ctx.arc(dayX, dayY - 5, daySize * 0.3, 0, 2 * Math.PI);
                            this.ctx.fill();
                        }

                        // Highlight today
                        if (currentDay === today.getDate()){
                           this.ctx.strokeStyle = '#8a2be2';
                           this.ctx.lineWidth = 1;
                           this.ctx.beginPath();
                           this.ctx.arc(dayX, dayY - 5, daySize*0.4, 0, 2 * Math.PI);
                           this.ctx.stroke();
                        }
                        
                        this.drawText(currentDay.toString(), dayX, dayY, 12, '#FFF');
                        currentDay++;
                    }
                }

            }

            drawTabs() {
                const tabs = ['Dashboard', 'Syllabus', 'Revision', 'Performance', 'Mindset'];
                const icons = ['üè†', 'üìö', 'üîÑ', 'üìä', 'üß†']; // Simple emoji icons
                const tabWidth = this.width / tabs.length;
                const tabY = this.height - 60;
                
                this.drawRoundedRect(0, tabY, this.width, 60, 0, 'rgba(30, 30, 50, 0.8)');
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                this.ctx.fillRect(0,tabY, this.width, 1);


                for (let i = 0; i < tabs.length; i++) {
                    const tab = tabs[i];
                    const icon = icons[i];
                    const x = i * tabWidth + tabWidth / 2;
                    
                    if (tab === this.currentTab) {
                        this.ctx.shadowBlur = 10 + Math.sin(this.glowAnimation) * 3;
                        this.ctx.shadowColor = '#8a2be2';
                        this.drawText(icon, x, tabY + 30, 24, '#FFF');
                         this.ctx.shadowBlur = 0;
                        this.drawText(tab, x, tabY + 50, 10, '#FFF');
                    } else {
                        this.drawText(icon, x, tabY + 35, 20, '#888');
                    }
                }
            }
            
            drawParticles() {
                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            // --- Main Game Loop ---
            gameLoop(timestamp) {
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                // --- Update Logic ---
                this.glowAnimation += 0.05;
                
                // Smooth scrolling
                this.touch.scrollOffset += (this.touch.targetScroll - this.touch.scrollOffset) * 0.1;
                
                // Pomodoro Timer
                if (this.state.pomodoro.isRunning && this.state.pomodoro.time > 0) {
                    this.state.pomodoro.time--;
                    if(this.state.pomodoro.mode === 'work') this.state.pomodoro.totalFocusTime++;
                } else if (this.state.pomodoro.time <= 0) {
                     this.state.pomodoro.isRunning = false;
                     if (this.state.pomodoro.mode === 'work') {
                         this.state.pomodoro.mode = 'break';
                         this.state.pomodoro.time = 5 * 60;
                     } else {
                         this.state.pomodoro.mode = 'work';
                         this.state.pomodoro.time = 25 * 60;
                     }
                }
                
                this.updateParticles();
                this.saveState();

                // --- Drawing Logic ---
                // Clear canvas
                this.ctx.clearRect(0, 0, this.width, this.height);

                // Draw dynamic gradient background
                const bgGradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
                const hue = (timestamp / 100) % 360;
                bgGradient.addColorStop(0, `hsl(${hue}, 40%, 10%)`);
                bgGradient.addColorStop(1, `hsl(${hue + 60}, 40%, 15%)`);
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Handle screen transitions
                if (this.transition.state === 'out') {
                    this.transition.alpha -= 0.1;
                    if (this.transition.alpha <= 0) {
                        this.transition.alpha = 0;
                        this.transition.state = 'in';
                        this.currentTab = this.transition.targetTab;
                    }
                } else if (this.transition.state === 'in') {
                    if (this.transition.alpha < 1) {
                       this.transition.alpha += 0.1;
                    } else {
                       this.transition.alpha = 1;
                    }
                }

                this.ctx.globalAlpha = this.transition.alpha;

                // Draw current screen
                if (!this.state.onboardingComplete) {
                    this.drawOnboarding();
                } else {
                    switch (this.currentTab) {
                        case 'Dashboard': this.drawDashboard(); break;
                        case 'Syllabus': this.drawSyllabus(); break;
                        case 'Revision': this.drawRevision(); break;
                        case 'Performance': this.drawPerformance(); break;
                        case 'Mindset': this.drawMindset(); break;
                    }
                    this.drawTabs();
                }
                
                this.drawParticles();
                this.ctx.globalAlpha = 1;


                requestAnimationFrame((t) => this.gameLoop(t));
            }
        }

        // Initialize the app
        new JEEAscentApp();
    };
    </script>
</body>
</html>




